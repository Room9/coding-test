# coding-test

0. 알고리즘 계획(아이디어) / 시간복잡도 / 사용 할 변수명,타입 -> 코드로 구현
핵심 : 알고리즘 계획(아이디어) 떠올리는 연습 위주로

1. codeup-basic 100제

2. input / output

3. 그리디
현재 상황에서 가장 좋은 것만 선택하는 방법, 정당성 확보 필수
% 그리디, 완전탐색, 다이나믹 프로그래밍은 일단 가장 먼저 생각한다

4. 구현(완전탐색/시뮬레이션)
머릿속의 아이디어와 알고리즘을 소스코드로 바꾸는 과정
완전탐색(brute force) : 모든 경우의 수를 주저없이 계산, 탐색할 데이터가 100만개 이하이면 시도
시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행, 좌표 내 주인공의 이동
% 메모리 제약
파이썬은 직접 자료형을 지정할 필요없으며, 큰 수에 대한 연산 또한 기본으로 지원
리스트 요소 100만개 = 40mb 수준, 일반적인 문제 내 메모리 제한은 128~512mb 수준
파이썬 기준 1초에 2000만번 연산을 기준으로 삼자
% 알고리즘에서 고려해야할 것
- 시간제한 : 1초기준
- 데이터 개수
- 시간복잡도의 알고리즘 : 데이터 갯수에 따라 bigO 결정


4. BFS/DFS - 데이터 탐색 방식
자료구조 : 스택, 큐, 그래프, 트리
백트래킹 : 재귀함수

[자료구조] : 데이터를 표현하고 관리하고 처리하기 위한 구조
(스택/큐) : 삽입(Push), 삭제(Pop), 오버플로, 언더플로

% 스택(Stack)
FILO 혹은 LIFO 구조
시간복잡도 O(1)
python 리스트 자료구조와 동일
삽입 - append() / 삭제 - pop()

% 큐(Queue)
FIFO 혹은 LILO 구조
시간복잡도 O(1)
python deque() 객체 사용 : 데이터 입출력 속도가 리스트 자료형에 비해 효율적
"""
from collections import deque

queue = deque()

# queue를 리스트로 이용 시
list(queue)
"""
삽입 - append() / 삭제 - popleft()

% 재귀함수
: 자기자신을 다시 호출하는 함수
메모리의 스택공간에 동일함수가 반복호출되면서 적재되는 형태
FILO / LIFO 순서로 호출되는 함수의 결과값이 리턴된다
재귀함수는 종료조건 명시가 필수
대표예시) 팩토리얼함수 / 유클리드호재법(최대공약수)
%% 유클리드 호제법
    두 자연수 a,b(a>b)에 대해 a를 b로 나눈 나머지를 r이라고 할 때
    a와 b의 최대공약수는 b와 r의 최대공약수와 같다

% (중요) 그래프 - 2차원 배열의 탐색문제는 그래프 형태로 변경해서 고민하자!!
기본구조 : 노드(node)/정점(vertex)와 간선(edge)으로 이루어져있다.
두 노드가 간선으로 연결되어있으면 '두 노드는 인접하다'라고 표현한다

그래프 표현방식 2가지 알아두기! (1)인접행렬 (2)인접리스트
(인접행렬)
2차원 배열에 각 노드의 연결 형태를 기록하는 방법
연결되어있지 않은 노드끼리는 무한(INF = int(1e9))이라고 작성한다
연결되어 있지 않은 노드끼리 형태로 표현해야해서 메모리 비효율적
특정 두 노드의 연결만 확인하는 경우 속도 우세

(인접리스트) - 가장 대중적
2차원 배열에 개별 노드에 대해 연결된 노드의 정보만 기록한다
연결된 노드에 대한 정보만 저장하기 때문에 메모리 효율적

[DFS]
깊이 우선 탐색, 가장 먼 곳부터 탐색한다 / 시간복잡도 O(N)
스택자료구조, 재귀함수 이용
    1. 탐색시작노드를 스택에 삽입하고 방문처리한다
    2. 스택의 최상단노드에 (방문하지 않은 인접 노드가 있으면) 그 인접노드를 스택에 넣고 방문처리한다
    (방문하지 않은 인접노드가 없으면) 스택에서 최상단 노드를 꺼낸다
    3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다
일반적으로 인접한 노드 중에 방문하지 않은 노드가 여러 개 있으면 번호가 낮은 순서부터 처리한다.

[BFS]
너비 우선 탐색, 가장 가까운 곳부터 탐색한다 / 시간복잡도 O(N)
큐자료구조, deque()를 사용한다.
    1. 탐색시작노드를 큐에 삽입하고 방문처리한다
    2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리한다
    3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다
일반적으로 인접한 노드가 여러 개 있으면 번호가 낮은 순서부터 처리한다.

5. 다이내믹 프로그래밍(DP)

% 점화식(133p)


